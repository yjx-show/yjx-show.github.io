<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hibernate (HQL操作) | 心动CCC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hibernate (HQL操作)： HQL是我们在hibernate中是常用的一种检索方式。HQL（Hibernate Query Language）提供更加丰富灵活、更为强大的查询能力因此Hibernate将HQL查询方式立为官方推荐的标准查询方式，……">
<meta name="keywords" content="Hibernate (HQL操作)">
<meta property="og:type" content="article">
<meta property="og:title" content="Hibernate (HQL操作)">
<meta property="og:url" content="http://yoursite.com/2018/06/10/Hibernate (HQL操作)/index.html">
<meta property="og:site_name" content="心动CCC">
<meta property="og:description" content="Hibernate (HQL操作)： HQL是我们在hibernate中是常用的一种检索方式。HQL（Hibernate Query Language）提供更加丰富灵活、更为强大的查询能力因此Hibernate将HQL查询方式立为官方推荐的标准查询方式，……">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-18T03:39:15.566Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hibernate (HQL操作)">
<meta name="twitter:description" content="Hibernate (HQL操作)： HQL是我们在hibernate中是常用的一种检索方式。HQL（Hibernate Query Language）提供更加丰富灵活、更为强大的查询能力因此Hibernate将HQL查询方式立为官方推荐的标准查询方式，……">
  
    <link rel="alternative" href="/atom.xml" title="心动CCC" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">心动CCC</a></h1>
        </hgroup>

        
        <p class="header-subtitle">很高兴遇见你  可以请你吃糖吗</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home-gh-pages/H1">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:492038605@qq.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/yjx-show/yjx-show.github.io.git" title="github">github</a>
                            
                                <a class="fl QQ" target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=492038605&site=qq&menu=yes" title="QQ">QQ</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Hibernate-HQL操作/" style="font-size: 10px;">Hibernate (HQL操作)</a> <a href="/tags/Hibernate注解详解/" style="font-size: 10px;">Hibernate注解详解</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Struts2/" style="font-size: 10px;">Struts2</a> <a href="/tags/Vue/" style="font-size: 20px;">Vue</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.jianshu.com/u/8569a7d98427">简书</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.senjoeson.xyz/">senjoeson</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">假装很陌生   其实很熟悉   很高兴遇见你</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">心动CCC</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">心动CCC</a></h1>
            </hgroup>
            
            <p class="header-subtitle">很高兴遇见你  可以请你吃糖吗</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home-gh-pages/H1">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:492038605@qq.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/yjx-show/yjx-show.github.io.git" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=492038605&site=qq&menu=yes" title="QQ">QQ</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Hibernate (HQL操作)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/10/Hibernate (HQL操作)/" class="article-date">
      <time datetime="2018-06-10T14:35:37.000Z" itemprop="datePublished">2018-06-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Hibernate (HQL操作)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Hibernate-HQL操作/">Hibernate (HQL操作)</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hibernate-HQL操作/">Hibernate (HQL操作)</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong> Hibernate (HQL操作)：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>HQL是我们在hibernate中是常用的一种检索方式。<br>HQL（Hibernate Query Language）提供更加丰富灵活、更为强大的查询能力<br>因此Hibernate将HQL查询方式立为官方推荐的标准查询方式，……<br><a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>正文……</the></p>
<h3 id="HQL介绍"><a href="#HQL介绍" class="headerlink" title="HQL介绍"></a>HQL介绍</h3><p>HQL是我们在hibernate中是常用的一种检索方式。<br>HQL（Hibernate Query Language）提供更加丰富灵活、更为强大的查询能力<br>因此Hibernate将HQL查询方式立为官方推荐的标准查询方式，HQL查询在涵盖Criteria查询的所有功能的前提下，提供了类似标准SQL语 句的查询方式，同时也提供了更加面向对象的封装。完整的HQL语句形式如下： Select/update/delete…… from …… where …… group by …… having …… order by …… asc/desc 其中的update/delete为Hibernate3中所新添加的功能，可见HQL查询非常类似于标准SQL查询。<br>基本步骤:</p>
<ol>
<li>得到Session</li>
<li>编写HQL语句</li>
<li>通过session.createQuery(hql)创建一个Query对象</li>
<li>为Query对象设置条件参数</li>
<li>执行list查询所有，它反回的是List集合  uniqueResut()返回一个查询结果。<h3 id="HQL查询的from子句"><a href="#HQL查询的from子句" class="headerlink" title="HQL查询的from子句"></a>HQL查询的from子句</h3>from是最简单的语句，也是最基本的HQL语句。from关键字后紧跟持久化类的类名。</li>
</ol>
<p>例如：</p>
<p>from Person  表明从Person持久化类中选出全部的实例</p>
<p>推荐为Person持久化类的每个实例起别名，例如：</p>
<p>from Person as p</p>
<p>p作为Person的实例的别名，因此也应该遵守Java的命名规则：第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<p>命名别名时，as关键字是可选的，但为了增加可读性，建议保留。</p>
<p>from 后还可同时出现多个持久化类，此时将产生一个笛卡尔积或跨表的连接，但实际上这种用法很少使用，因为通常我们可能需要使用跨表的连接，此时可以考虑使用隐式连接或显示连接，而不是直接在from后紧跟多个表名。</p>
<h3 id="关联和连接"><a href="#关联和连接" class="headerlink" title="关联和连接"></a>关联和连接</h3><p>Hibernate使用关联映射来处理底层数据表之间的连接，一旦我们提供了正确的关联映射后，当程序通过Hibernate进行持久化访问时，将可利用Hibernate的关联来进行连接。</p>
<pre><code>HQL支持两种关联连接(join)的形式：隐式(implicit)与显示(explicit)。
</code></pre><p>隐式连接形式不适用join关键字，使用英文点号(.)来隐式连接来关联实体，而Hibernate底层将自动进行关联查询。如下HQL语句：</p>
<p>from Person p where p.myEvent.title &gt; :title</p>
<p>上面的p.myEvent属性的实质是一个持久化实体，因此Hibernate底层隐式地自动进行连接查询。</p>
<p>显示连接则需要使用xxx join关键字，例如如下语句：</p>
<p>//使用显示连接</p>
<p>from Person p</p>
<p>inner join p.myEvent event</p>
<p>where event.happenDate &lt; :endDate</p>
<p>使用显示连接时，可以为相关联的实体，甚至是关联集合中的全部元素指定一个别名。</p>
<p>Hibernate支持的HQL连接类型，可使用如下几种连接方式：</p>
<p>inner join(内连接)，可简写成join。</p>
<p>left outer join(左外连接)，可简写成left join。</p>
<p>right outer join(右外连接)，可简写成right join。</p>
<p>full join(全连接)，并不常用。</p>
<p>使用显示连接时，还可通过HQL的with关键字来提供额外的连接条件，例如如下HQL语句：</p>
<p>from Person p</p>
<p>inner join p.myEvent event</p>
<p>with p.id &gt; event.id</p>
<p>where event.happenDate &lt; :endDate</p>
<pre><code> HQL语句中的with关键字的作用基本等同于SQL99中on关键字的作用：都是用于指定连接条件。通过在HQL语句中使用with关键字，可以让HQL语句执行非等值连接查询。

由于表连接的方式都是基于底层SQL来实现的，如果底层不支持这些外连接，那么执行对应的HQL时就会相应地引发异常。
</code></pre><h3 id="隐式连接和显示连接有如下两点区别"><a href="#隐式连接和显示连接有如下两点区别" class="headerlink" title="隐式连接和显示连接有如下两点区别"></a>隐式连接和显示连接有如下两点区别</h3><p>（1）隐式连接底层转换成SQL92的内连接，显示连接层将转换成SQL99的多表连接。</p>
<p>（2）隐式连接和显示连接查询后返回的结果不同。</p>
<p>当HQL语句中省略select关键字时，使用隐式连接查询返回的结果是多个被查询实体组成的集合。</p>
<p>当HQL语句中省略select关键字时，使用显示连接查询返回的结果也是集合，但集合元素是被查询持久化对象、所有被关联的持久化对象所组成的数组。</p>
<p> 注意：</p>
<pre><code>对于Hibernate3.2.3以后的版本，如果关联实体是单个实体或单个的组件属性，HQL依然可以似乎用英文点号（.）来隐式连接关联实体或组件；但如果关联实体是集合（包括1-N关联、N-N关联和集合元素时组件等），则必须使用xxx join来显示连接关联实体或组件。

对于集合属性的，Hibernate默认采用延迟加载策略，解决办法：

（2.1）可以在Hibernate映射文件中指定lazy=&quot;false&quot;来关闭延迟加载。

（2.2）使用join fetch，通常无须指定别名，因为相关联的对象不应当在where子句（或其他任何子句）中使用。而且被关联的对象也不会再被查询的结果中直接返回，而是应该通过其父对象来访问。
</code></pre><p>使用fetch关键字时，有如下几个注意点：</p>
<pre><code> fetch不应该与setMaxResults()或setFirstResult()共用。因为这些操作是基于结果集的，而在预先抓取集合类时可能包含重复的数据，即无法预先知道精确的行数。

 fetch不能与独立的with条件一起使用。

 如果在一次查询中fetch多个集合，可以查询返回笛卡尔积，因此请多加注意。

 对bag映射而言，同时join fetch多个集合时可能出现非预期结果，因此需要谨慎使用。

full join fetch 与right join fetch是没有任何意义的。
</code></pre><p>程序里希望预加载那些原本应延迟加载的属性，则可以通过fetch all properties来强制Hibernate立即抓取这些属性。例如：</p>
<p>from Document fetch all properties order by name</p>
<h3 id="HQL查询的select子句"><a href="#HQL查询的select子句" class="headerlink" title="HQL查询的select子句"></a>HQL查询的select子句</h3><p>（1）select子句用于选择指定的属性或直接选择某个实体，当然select选择的属性必须是from后持久化类包含的属性。</p>
<p>例如：</p>
<p>select p.name from Person as p</p>
<p>（2）select可以选择任意属性，即不仅可以选择持久化类的直接属性，还可以选择组件属性包含的属性。例如：</p>
<p>select p.name.firstName from Person as p</p>
<p>（3）在特殊情况下，如果select后只有一项（包括持久化实例或属性），则查询得到的集合元素就是该持久化实例或属性。</p>
<p>（4）如果select后有多个项，则每个集合就是选择出的多项组成的数组。</p>
<p>例如：</p>
<p>select p.name,p from Person as p</p>
<p>执行该HQL语句得到的集合元素时类似于[String,Person]结构的数组，其中第一个元素时Person实例的name属性，第二个元素时Person实例。</p>
<p>注意：即使select后的列表项选出某个持久化类的全部属性，这些属性依然是属性，Hibernate不会将这些属性封装成对象。只有在select后的列表里给出持久化类的别名（其实就是实例名），Hibernate才会将该项封装成一个持久化实体。</p>
<p>（5）select支持将选择出的属性存入一个List对象中。</p>
<p>例如：</p>
<p>select new list(p.name, p.address) from Person as p</p>
<p> （6）select支持将选择出的属性封装成对象，前提是该对象拥有支持这些属性的构造器。</p>
<p>例如：</p>
<p>select new ClassTest(p,name, p.address) from Person as p;</p>
<p>而ClassTest必须有如下的构造器：ClassTest(String s1, String s2)</p>
<p>（7）select还支持给选中的表达式命名别名。例如：</p>
<p>select p.name as personName from Person as p</p>
<p>这种用法与new map 结合使用更普遍。例如：</p>
<p>select new map(p.name as personName) from Person as p</p>
<p>执行上面的HQL语句返回的结果是集合，其中集合元素时Map对象，以personName作为Map的key，实际选出的值作为Map的value。</p>
<h3 id="HQL查询的聚集函数"><a href="#HQL查询的聚集函数" class="headerlink" title="HQL查询的聚集函数"></a>HQL查询的聚集函数</h3><p>HQL支持的聚集函数与SQL的完全相同：avg，count，max，min，sum。</p>
<p>例如，如下的HQL语句：</p>
<p>select count(*) from Person</p>
<p>select max(p.page) from Person as p</p>
<p>select子句还支持字符串连接符、算术连接符，以及SQL函数。例如：</p>
<p>select p.name||””||p.address from Person as p</p>
<p>select子句也支持使用distinct和all关键字，此时的效果与SQL的效果完全相同。</p>
<h3 id="多态查询"><a href="#多态查询" class="headerlink" title="多态查询"></a>多态查询</h3><p> HQL语句被设计成能够理解多态查询，from后跟持久化类名，不仅会查询出该持久化类的全部实例，还会查询出该类的子类的全部实例。</p>
<p>如下面的查询语句：from Person as p</p>
<pre><code>如果Named接口有多个持久化实现类，下面的语句将返回这些持久化类的全部实例。
</code></pre><p>如下面的查询语句：from Named as n</p>
<p>注意：上面最后一条查询，需要多个SQL SELECT 语句，因此无法使用order by子句对结果集排序，从而不允许对这些查询结果使用Query.scroll()方法。</p>
<h3 id="HQL查询的where子句"><a href="#HQL查询的where子句" class="headerlink" title="HQL查询的where子句"></a>HQL查询的where子句</h3><p>（1）where子句用于筛选选中的结果，缩小选择的范围。如果没有为持久化实例命名别名，则可以直接使用属性名来引用属性。</p>
<p>如下面两条HQL语句：</p>
<p>from Person where name like “tom%”</p>
<p>form Person as p where p.name like “tom%”</p>
<p>（2）复合属性表达式加强了where子句的功能，例如，如下的HQL语句：</p>
<p>from Cat cat where cat.mate.name like “kit%”</p>
<p>上面语句被翻译成以下含有内连接的SQL查询：</p>
<p>select * from cat_table as table1 cat_table as table2</p>
<p>where table1.mate = table2.mate</p>
<p>and table1.name like ‘’’kit%’”</p>
<p>实际上这种用法使用了隐式连接查询，从Hibernate3.2.3之后，只有当cat,mate属性引用的是普通组件属性或者单独的关联实体时才可接着在后面使用点好（.）来引用mate属性，如cat,mate.name； 如果cat,mate是集合属性，Hibernate3.2.3以后的版本不支持这种用法。</p>
<p>“=”号不仅可以被用来比较属性的值，也可以用来比较实例。</p>
<p>select cat,mate from Cat cat, Cat mate where cat.mate = mate</p>
<p>（3）在进行多态持久化的情况下，class关键字用来存取一个实例的鉴别值。嵌入where子句的Java类名，将被作为该类的鉴别值。</p>
<p>//执行多态查询时，默认会选出Cat及其所有子类的实例</p>
<p>//在如下HQL语句中，将只选出DomesticCat类的实例</p>
<p>from Cat cat where cat.class = DomesticCat</p>
<p>（4）当where子句中的运算符只支持基本类型或者字符串时，where子句中的属性表达式必须以基本类型或者字符串结尾，不要使用组件类型属性结尾，例如Account和Person属性，而Person有Name属性，Name属性有firstName属性。</p>
<p>如下所示：</p>
<p>//firstName是字符串</p>
<p>from Account as a where a.person.name.firstName like “dd%”</p>
<p>//下面是错误实例</p>
<p>from Account as a where a.person.name like “dd%”</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>1、HQL的功能非常丰富，where子句后支持的运算符，不仅包括SQL的运算符，也包括EJB-QL的运算符等。</p>
<p>where子句中允许使用大部分SQL支持的表达式，包括如下种类：</p>
<p>（1）字符串连接：如value1||value2，或使用字符串连接函数concat(value1, value2)</p>
<p>（2）简单的case，case…when…then…else…end和case，case when…then…else…end等。</p>
<p>（3）时间操作函数：current_date()、current_time、year()等。</p>
<p>（4）EJB-QL3.0的函数：substring()、trim()、abs()、sqrt()等。</p>
<p>（5）可在where子句中使用SQL常量。</p>
<p>（6）在HQL语句中使用Java中的public static final类型的常量，例如Color.RED</p>
<p>（7）HQL语句支持使用英文问号（？）作为参数占位符，这与JDBC的参数占位符一致；也使用命名参数占位符号，方法在参数名前加英文冒号（：），例如:start_date等。</p>
<p>（8）如果底层数据库支持单行函数，则HQL语句也完全可以支持。</p>
<p>（9）支持数据库的类型转换函数，如cast（… as …），第二个参数是Hibernate的类型名，或者extract(… from ,,,)，前提是底层数据库支持ANSI cast()和extract()。</p>
<p>2、如果在Hibernate配置文件中进行如下声明：</p>
<property name="hibernate.query.substitutions">true 1,false 0</property>

<p>上面的声明表明：HQL转换SQL语句时，将使用字符1和0来取代关键字true和false，然后将可以在表达式中使用布尔表达式。</p>
<p>3、有用的elements()和indices函数，用于返回指定集合的所有元素和所有索引。</p>
<p>4、在where子句中，有序集合（数组、List集合、Map对象）的元素可以通过【】运算符来访问。如下：</p>
<p>from Order order where order.items[0].id=1234</p>
<p>在【】中的表达式甚至可以是一个算式表达式。</p>
<p>5、结构变量：size、elements、indices等，只能在where子句中使用。</p>
<h3 id="order-by子句"><a href="#order-by子句" class="headerlink" title="order by子句"></a>order by子句</h3><p>查询返回的集合根据类或组件属性的任何属性进行排序。例如：</p>
<p>from Person as p order by p.name,p.age</p>
<p>还可以使用as或desc关键字指定升序或降序的排序规则。例如：</p>
<p>from Person as p order by p.name asc，p.age desc</p>
<p>如果没有指定排序规则，默认采用升序规则。</p>
<p>十、group by子句</p>
<p>返回聚集值的查询可以对持久化类或组件属性的进行分组，分组使用group by子句。看下面的HQL查询语句：</p>
<p>select cat,color,sum(cat.weight),count(cat) from Cat cat group by cat.color</p>
<p>其规则类似于SQL规则。</p>
<p>having子句用于对分组进行过滤，如下所示：</p>
<p>select cat,color,sum(cat.weight),count(cat) from Cat cat group by cat.color having cat.color in (eg.Color.TABBY,eg.Color.BLACK)</p>
<p>注意：group by子句与order by 子句中都不能包含算术表达式</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>1）如果底层数据库支持子查询，则可以在HQL语句中使用子查询。如下：</p>
<p>from Cat as fatcat where fatcat.weight &gt; (select avg(cat.weight) from DomesticCat cat)</p>
<p>（2）如果子查询是多行结果集，则应该使用多行运算符。如下：</p>
<p>from Cat as cat where not(cat.name, cat.color) in (select cat.name, cat.color from DomesticCat cat)</p>
<p>（3）SQL语法中子查询还可以出现在select子句之后，HQL也支持这种用法，看如下HQL语句：</p>
<p>select cat.id,(select max(kit.weight) from cat.kitten kit)</p>
<p>from Cat as cat</p>
<p>注意：HQL子查询只可以在select子句或者where子句中出现。</p>
<h3 id="命名查询"><a href="#命名查询" class="headerlink" title="命名查询"></a>命名查询</h3><p>HQL支持将查询所用的HQL语句放入配置文件中，而不是代码中。</p>
<p>在Hibernate映射文件的<hibernate-mapping>元素中使用<query>子元素来定义命名查询，使用<query>元素只需要指定一个name属性，指定该命名查询的名字。该元素的内容就是命名查询的HQL语句。如下配置文件片段：</query></query></hibernate-mapping></p>
<query name="myNameQuery"><br><br>        from Person as p where p.age &gt; ?<br><br></query>

<p>配置好后，通过Session提供的一个getNameQuery(String name)方法，该方法用于创建一个Query对象，剩下的操作与普通HQL完全一样。如下所示：</p>
<p>List p1 = sess.getNamedQuery(“myNameQuery”).setInteger(0,20).list()</p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>条件查询通过如下3个类完成：</p>
<p>Criteria：代表一次查询。</p>
<p>Criterion：代表一个查询条件。</p>
<p>Restrictions：产生查询条件的工具类。</p>
<p>执行条件查询的步骤如下：</p>
<p>（1）获得Hibernate的Session对象。</p>
<p>（2）以Session对象创建Criteria对象。</p>
<p>（3）使用Restrictions的静态方法创建Criterion查询条件。</p>
<p>（4）向Criteria查询中体检Criterion查询条件。</p>
<p>（5）执行Criteria的list等方法返回结果集。</p>
<p>代码片段如下：</p>
<p>List l = session.createCriteria(Student.class)</p>
<pre><code>//此处增加限制条件必须是Student已经存在的属性

 .add(Restrictions.get(&quot;studentNumber&quot;, 20050231L))

//如果要增加对Student的关联类的属性的限制

//则必须重新createCriteria()

//如果此关联属性是集合，则只要集合里任意一个对象的属性满足下面条件即可

.createCriteria(&quot;enrolments&quot;)

.add(Restrictions.gt(&quot;semester&quot;,2))

.list();
</code></pre><p>在条件查询中，Criteria接口代表依次查询，该查询本身不具备任何的数据筛选功能，Session调用createCriterial(Class clazz)方法对某个持久化类创建条件查询实例。</p>
<p>Criteria对象不具备任何的数据筛选功能，但程序可以通过向Criteria对象中组合多个Criterion（每个Criterion对象代表一个过滤条件）即可实现数据过滤了。</p>
<p>Criterion接口代表一个查询条件，该查询条件由Restrictions负责产生。Restrictions是专门用于产生查询条件的工具类，它的方法大部分都是静态方法，常用的方法如下：</p>
<p>（1）static Criteion allEq(Map propertyNameValues)：判断指定属性(由Map参数的key指定)和指定值(由Map参数的value指定)是否完全相等。</p>
<p>（2）static Criterion between(String propertyName, Object lo, Object hi)：判断属性值在某个指范围之内。</p>
<h3 id="关联和动态关联"><a href="#关联和动态关联" class="headerlink" title="关联和动态关联"></a>关联和动态关联</h3><p>代码片段如下：</p>
<p>List l = session.createCriteria(Student.class)</p>
<pre><code>//此处增加限制条件必须是Student已经存在的属性

 .add(Restrictions.get(&quot;studentNumber&quot;, 20050231L))

//如果要增加对Student的关联类的属性的限制

//则必须重新createCriteria()

//如果此关联属性是集合，则只要集合里任意一个对象的属性满足下面条件即可

.createCriteria(&quot;enrolments&quot;)

.add(Restrictions.gt(&quot;semester&quot;,2))

.list();
</code></pre><p>上面的代码表示建立Person类的条件查询，第一个查询条件是直接过滤Person的属性。第二个查询条件则过滤Person的关联实体的属性，其中enrolments是Person类的关联实体，而semester则是Enrolment类的属性。值得注意的是，返回的并不是Enrolment对象，而是Person对象的集合。</p>
<p>注意：使用关联类的条件查询，依然是查询原有持久化类的实例，而不是查询被关联类的实例。</p>
<p>可使用条件查询支持的替换形态，将上面查询代码替换成如下形式：</p>
<p>List l = session.createCriteria(Student.class)</p>
<pre><code>.add(Restrictions.gt(&quot;studentNumber&quot;,20050231L))

.createAlias(&quot;enrolments&quot;,&quot;en&quot;)

.add(Restrictions.gt(&quot;semester&quot;,2))

 .list();
</code></pre><p>createAlias()方法并不创建一个新的Criteria实例，它只是给关联实体（包含集合里包含的关联实体）起一个别名，让后面过滤条件可根据关联实体进行筛选。</p>
<p>在默认情况下，条件查询将根据映射文件指定的延迟加载策略来加载关联实体，如果希望在条件查询中改变延迟加载策略（就像在HQL查询中使用fetch关键字一样），那就可通过Creteria的setFetchMode()方法来实现，该方法接受一个FetchMode参数。</p>
<p>FetchMode里有几个常量，如下：</p>
<p>DEFAULT：使用配置文件制定的延迟加载策略处理。</p>
<p>JOIN：使用外连接，预初始化所有关联实体。</p>
<p>SELECT：启用延迟加载，系统将使用单独的select语句来初始化关联实体。只有当个真正访问关联实体的时候，才会执行第二条select语句。</p>
<p>初始化Student对象时，也可以初始化Student关联的Enrolment实体，实体使用如下代码：<br>List l = session.createCriteria(Student.class)</p>
<pre><code>.add(Restrictions.gt(&quot;studentNumber&quot;,20050231L))

.setFetchMode(&quot;enrolments&quot;, FetchMode.JOIN)

.list();
</code></pre><h3 id="投影、聚合和分组"><a href="#投影、聚合和分组" class="headerlink" title="投影、聚合和分组"></a>投影、聚合和分组</h3><p>投影运算实际上就是一个基于列的运算，通常用于投影到指定列（也就是过滤其他列，类似select子句的作用），还可以完成SQL语句中常用的分组、组筛选等功能。</p>
<p>Hibernate的条件过滤中使用Projection代表投影运算，Projection是一个接口，而Projections作为Projection的工厂，负责生成Projection对象。</p>
<p>一旦产生了Projection对象之后，就可通过Criteria提供的setProjection(Projection projection)方法来进行投影运算。从该方法上看，每个Criteria只能接受一个投影运算，似乎无法进行多个投影运算，但实际上Hibernate又提供了一个ProjectionList类，该类是Projection的子类，并可以包含多个投影运算，通过这种方式即完成多个投影运算。</p>
<p>因此，一个条件查询的投影运算通常有如下程序结构：</p>
<p>List cats = session.createCriteria(Cat.class)</p>
<pre><code>.setProjection(Projections.projectionList()

.add(Projections.rowCount())

.add(Projections.avg(&quot;weight&quot;))

.add(Projections.groupProperty(&quot;color&quot;))

 ).addOrder(Order.asc(&quot;color&quot;))

 .list();
</code></pre><p>注意：使用条件查询的投影运算时，不能使用显示的分组子句，但某些投影类型的实质就是分组投影，这些投影元素将出现在SQL的group by子句中——如上的groupProperty(“color”)投影。</p>
<p>投影运算的实质和group by子句、聚集函数的功能大致一致。</p>
<p>除此之外，如果我们希望对分组（投影）后属性进行排序，那就需要为投影运算指定一个别名。为投影运算指定别名有3种方法：</p>
<p>（1）使用Projections的alias()方法为指定投影指定别名。一旦为projection指定了别名，则程序就可以根据该Projection别名来进行其他额外操作了，比如排序。条件查询片段如下：</p>
<p>List l = session.createCriteria(Enrolment.class)</p>
<pre><code>.setProjection(Projections.projectionList()

 //按course进行分组

.add(Projections.groupProperty(&quot;course&quot;))

//统计记录条数，并为统计结果指定别名c

.add(Projections.alias(Projections.rowCount(),&quot; c&quot;))

  ).addOrder(Order, asc(&quot;c&quot;))

.list();
</code></pre><p>（2）使用SimpleProjection的as()方法为自身指定别名。</p>
<p>List l = session.createCriteria(Enrolment.class)</p>
<pre><code>.setProjection(Projections.projectionList()

 //按course进行分组

.add(Projections.groupProperty(&quot;course&quot;).as(&quot;c&quot;))

//统计记录条数，并为统计结果指定别名c

.add(Projections.rowCount())

  ).addOrder(Order, asc(&quot;c&quot;))

.list();
</code></pre><p>（3）使用ProjectionList的add()方法添加投影时指定别名。</p>
<p>ProjectionList的add()方法有两个重载形式，一个是直接添加投影，另一个是在添加投影时指定别名。条件查询片段如下：</p>
<p>List l = session.createCriteria(Enrolment.class)</p>
<pre><code>.setProjection(Projections.projectionList()

 //按course进行分组，指定别名为c

.add(Projections.groupProperty(&quot;course&quot;),(&quot;c&quot;))

//统计记录条数，并为统计结果指定别名rc

.add(Projections.rowCount(),&quot;rc&quot;)

  ).addOrder(Order, asc(&quot;c&quot;))

.list();
</code></pre><p>除此之外，Hibernate还提供了Property执行投影运算，Property投影的作用类似于SQL语句中的select，条件查询的结果只有被Property投影的列才会被选出，条件查询片段如下：</p>
<p>List l = session.createCriteria(Student.class)</p>
<pre><code>.setProjection(Property.forName(&quot;name&quot;))

.list();
</code></pre><p>上面条件查询执行的结果不再是Student对象集合，而是name属性所组成的集合。</p>
<h2 id="离线查询和子查询"><a href="#离线查询和子查询" class="headerlink" title="离线查询和子查询"></a>离线查询和子查询</h2><p>条件查询的离线查询由DetachedCriteria来代表，DetachedCriteria类使你在一个session范围之外创建一个查询，并且可以使用任意的Session来执行它。</p>
<p>DetachedCriteria还可代表子查询，当我们把DetachedCriteria传入Criteria中作为查询条件时，DetachedCriteria就变成了子查询。以下代码片段所示：</p>
<p>//定义一个离线查询</p>
<p>DetachedCriteria query = DetachedCriteria.forClass(Student.class)</p>
<pre><code>.forClass(Student.class)

.setProjection(Property.forName(&quot;name&quot;));
</code></pre><p>//打开Session和事务（省略）</p>
<p>//执行离线查询</p>
<p>List l = query.getExecutableCriteria(session).list();</p>
<p>//执行子查询</p>
<p>List l = session.createCriteria(Student.class)</p>
<pre><code>.add(Property.forName(&quot;name&quot;).in(query))

.list();
</code></pre><p>如果程序使用Session的getExecutableCriteria()方法来执行DetachedCriteria对象，则它被当成离线查询使用；如果程序使用Property的系列方法来操作DetachedCriteria对象，则它被当成子查询使用。</p>
<h3 id="事务和Session"><a href="#事务和Session" class="headerlink" title="事务和Session"></a>事务和Session</h3><p>1、Session和用户请求是一对一得关系，这是一种理想的Session管理模式。</p>
<p>为了达到这种效果，推荐使用一个ThreadLocal变量，把Session绑定到处理客户端请求的线程上。这种方式可以让运行在该线程上的所有程序代码轻松地访问Session。也可以在一个ThreadLocal变量中保持事务上下文环境，不过这依赖于你所选择的数据库事务划分机制。这种实现模式被称为ThreadLocal Session和Open Session in View。</p>
<p>工具类代码如下：<br>public class HibernateUtil</p>
<p>{</p>
<pre><code>//使用一个final变量来保存不可变的SessionFactory

public static final SessionFactory sessionFactory;
</code></pre><p>static{</p>
<pre><code>try{

    //采用默认的Hibernate.cfg,xml来启动一个Configuration的实例

    Configuration conf = new Configuration().configure();

    //由conf实例创建一个SessionFactory实例

    sessionFactory = conf.buildSessionFactory();

    }catch(Throwable ex){

            System.err.println(&quot;初始化SessionFactory出现异常：&quot;+ex);

            throw new ExceptionInitializerError(ex);

   }

}
</code></pre><p>//ThreadLocal是隔离多个线程的数据共享</p>
<p>//不存在多个线程之间共享资源，因此不再需要对线程同步</p>
<pre><code>public static final ThreadLocal session = new ThreadLocal();

public static Session currentSession() throws HibernateException

{

      Session s = (Session)session.get();

      //如果该线程还没有Session，则创建一个新的Session

      if(s == null)

      {

          s = sessionFactory.openSession();

      //将获得的Session变量存储在ThreadLocal变量session里

           session.set(s);

       }

       return s;

 }

 public static void closeSession() throws HibernateException

 {

      Session s = (Session)session.get();

      if(s != null)

      {

             s.close();

             session.set(null);

      }

 }
</code></pre><p>}</p>
<p>在上面的代码中，Hibernate Session被绑定到当前线程。当调用currentSession方法时，如果当前线程中的Session已经创建出来，那么将返回这个已经存在的Session实例。</p>
<p>注意：几乎所有情况下，都不要使用每个应用对应一次Hibernate Session的模式，也不要使用每次Http Session对应一次Hibernate Session的模式。</p>
<p>2、对于以上的情况，Hibernate主要有如下3种模式来解决这个问题：</p>
<p>（1）自动版本化：Hibernate能够自动进行乐观并发控制，如果在用户思考的过程中持久化实体发生并发修改，Hibernate能够自动检测到。</p>
<p>（2）脱管现象：如果采用每次用户请求对应一次Session的模式，那么，前面载入的实例在用户思考的过程中，始终与Session脱离，处于脱管状态。Hibernate允许把脱管对象重新关联到Session上，并且对修改进行持久化。在这种模式下，自动版本化被用来隔离并发修改。这种模式也被称为脱管对象的每次请求对应一个Hibernate Session。</p>
<p>（3）长生命周期Session：Session可以在数据库事务提交之后，断开和底层的JDBC连接。当新的客户端请求到来时，它又重新连接上底层的JDBC链接。这种模式被称为每个应用程序事务对应一个Session。因为应用程序事务时相当长（跨越多个用户请求）的，所以也被称为长生命周期Session。</p>
<p>注意：Session缓存了处于持久化状态的每个对象（Hibernate会监视和检查脏数据），也就是说，如果程序让Session打开很长一段时间，或者载入了很多数据，Session占用的内存会一直增长，直到抛出OutOfMemoryException异常。为了解决这个问题，程序定期调用Session的clear()和evict()方法来管理Session的缓存。对于一些大批量的数据处理，推荐使用DML风格的HQL语句完成。</p>
<p>3、为了保证在Session关闭之前初始化代理属性或集合属性，程序可以Hibernate,initialized()静态方法来强制初始化集合或代理。只要Session处于open状态，Hibernate.initialize(teahcer)将会强制初始化teacher代理，Hibernate.initialize(teacher.getStudents())对student的集合具有同样的功能。</p>
<p>还有另一种选择，就是程序让Session一直处于打开状态，直到装入所有需要的集合或代理。</p>
<p>保证Session处于打开状态有两种方法可以解决此问题：</p>
<p>（1）在一个Web应用中，可以利用过滤器（Filter），在用户请求结束、页面生成结束时关闭Session。也就是保证在视图层一直打开Session，这就是所谓的Open Session in View成视图界面的过程中发生异常时，必须保证可以正确关闭Session，并结束事务。</p>
<p>（2）使用业务逻辑层来准备数据，在业务逻辑层返回数据之前，业务逻辑层对每个所需集合调用Hibernate.initialize()方法，或者使用带fetch子句或FetchMethod.JOIN的查询，事先取得所有数据，并将这些数据封装成VO（值对象）集合，然后程序可以关闭Session了。业务逻辑层VO集传入视图层，让视图层只负责简单的显示逻辑。在这种模式下，可以让视图层和Hibernate API彻底分离，保证视图层不会出现持久层API，从而提供更好的解耦。</p>
<h3 id="上下文相关的Session"><a href="#上下文相关的Session" class="headerlink" title="上下文相关的Session"></a>上下文相关的Session</h3><p>从Hibernate3.1开始，SessionFactory.getCurrentSession()的底层实现是可插拔的，Hibernate引入了CurrentSessionContext接口，并通过hibernate_current_session_context_class参数来管理上下文相关Session的底层实现。</p>
<p>CurrentSessionContext接口有如下3个实现类：</p>
<p>org.hibernate.context.JTASessionContext：根据JTA来跟踪和界定上下文相关Session，这和最早的仅支持JTA的方法是完全一样的。</p>
<p>org.hibernate.context.ThreadLocalSessionContext：通过当前正在执行的线程来跟踪和界定上下文相关Session，也就是和前面的HibernateUtil的Session维护模式相似。</p>
<p>org.hibernate.context.ManagedSessionContext：通过当前执行的线程来跟踪和界定上下文相关的Session。但是程序需要使用这个类的静态方法将Session实例绑定、取消绑定，它并不会自动打开、flush或者关闭任何Session。</p>
<p>对于容器中使用Hibernate的场景而言，通常会采用第一种方式：对于独立的Hibernate应用而言，通常会采用第二种方式。</p>
<p>为了指定Hibernate使用哪种Session管理方式，可以在hibernate.cfg.xml文件中增加如下片段：</p>
<property name="hibernate.current_session_context_class">thread</property>

<p>如果在JTA事务环境中，则应增加如下配置片段：</p>
<property name="hibernate.current_session_context_class">jta</property>

<p>对于第三种不常用的Session管理机制，则可在配置文件中简写成：managed。</p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>纯属好玩</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weixin.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/06/10/Hibernate (HQL操作)/">Hibernate (HQL操作)</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 心动CCC 的个人博客">心动CCC</a></p>
        <p><span>发布时间:</span>2018年06月10日 - 22时35分</p>
        <p><span>最后更新:</span>2018年06月18日 - 11时39分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/06/10/Hibernate (HQL操作)/" title="Hibernate (HQL操作)">http://yoursite.com/2018/06/10/Hibernate (HQL操作)/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/06/10/Hibernate (HQL操作)/　　作者: 心动CCC" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2018/06/10/hibernate注解详解/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Hibernate注解详解
        
      </div>
    </a>
  
  
    <a href="/2018/06/10/vue5/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（五）配置 Axios api 接口调用文件</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HQL介绍"><span class="toc-number">1.</span> <span class="toc-text">HQL介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HQL查询的from子句"><span class="toc-number">2.</span> <span class="toc-text">HQL查询的from子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联和连接"><span class="toc-number">3.</span> <span class="toc-text">关联和连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式连接和显示连接有如下两点区别"><span class="toc-number">4.</span> <span class="toc-text">隐式连接和显示连接有如下两点区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HQL查询的select子句"><span class="toc-number">5.</span> <span class="toc-text">HQL查询的select子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HQL查询的聚集函数"><span class="toc-number">6.</span> <span class="toc-text">HQL查询的聚集函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态查询"><span class="toc-number">7.</span> <span class="toc-text">多态查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HQL查询的where子句"><span class="toc-number">8.</span> <span class="toc-text">HQL查询的where子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表达式"><span class="toc-number">9.</span> <span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by子句"><span class="toc-number">10.</span> <span class="toc-text">order by子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子查询"><span class="toc-number">11.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名查询"><span class="toc-number">12.</span> <span class="toc-text">命名查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件查询"><span class="toc-number">13.</span> <span class="toc-text">条件查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联和动态关联"><span class="toc-number">14.</span> <span class="toc-text">关联和动态关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#投影、聚合和分组"><span class="toc-number">15.</span> <span class="toc-text">投影、聚合和分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#离线查询和子查询"><span class="toc-number"></span> <span class="toc-text">离线查询和子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事务和Session"><span class="toc-number">1.</span> <span class="toc-text">事务和Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文相关的Session"><span class="toc-number">2.</span> <span class="toc-text">上下文相关的Session</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <div id="gitments"></div>
<script src="/js/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
      id: window.location.pathname,
      owner: 'yjx-show',
      repo: 'yjx-show.github.io',
      oauth: {
        client_id: '637964a4506d86e3b0cf',
        client_secret: 'e4200cca59e5de9a2cd78c53fbe1a7c37157e9a0',
      },
    })
    gitment.render('gitments')
</script>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/06/10/hibernate注解详解/" title="上一篇: Hibernate注解详解">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2018/06/10/vue5/" title="下一篇: Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（五）配置 Axios api 接口调用文件">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/vue11/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（十一）idea运行vue项目(解决前后端分离跨域问题)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/15/vue10/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（十）打包项目并发布到子目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/vue9/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（九）再把内容页面渲染出来</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/spring框架/">Spring框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/vue8/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（八）渲染一个列表出来先</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/12/vue7/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（七）初识 *.vue 文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/11/vue6/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（六）将接口用 webpack 代理到本地</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/10/hibernate注解详解/">Hibernate注解详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/10/Hibernate (HQL操作)/">Hibernate (HQL操作)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/10/vue5/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（五）配置 Axios api 接口调用文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/09/vue4/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（四）调整 App.vue 和 router 路由</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/struts2框架核心技术总结/">Struts2框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/vue3/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（三）认识项目所有文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/vue2/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（二）安装 nodejs 环境以及 vue-cli 构建初始项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/vue1/">Vue2+VueRouter2+Webpack+Axios 构建项目实战2017（一）基础知识概述</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 心动CCC
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/yjx-show/yjx-show.github.io" target="_blank">心动CCC</a> by 心动CCC
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >心心到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>